#!/usr/bin/env python3
import filecmp
import json
import os
import sys
import shutil
from collections import OrderedDict
from fnmatch import fnmatchcase

import sh
from jinja2 import Environment, TemplateNotFound

from qbuild.color_print import Color, cprint
from qbuild.helpers import ls_recursive, load_statement_templates, uncomment
from qbuild.tree import tree


class Builder:
    SOLUTION_COMMENT_BEGIN = ['_q_hide_from_users_begin', '_q_solution_begin']
    SOLUTION_COMMENT_REPLACE = ['_q_solution_replace']
    SOLUTION_COMMENT_END = ['_q_hide_from_users_end', '_q_solution_end']

    EXPORT_INITIAL = {
        'code': 'initial',
        'export_name': '{slug}_initial',
        'hide_solution': True,
        'hide_test': True
    }

    EXPORT_MODEL_SOLUTION = {
        'code': 'model_solution',
        'export_name': 'model_solution',
        'hide_solution': False,
        'hide_test': True
    }

    EXPORT_TEST = {
        'code': 'test',
        'export_name': 'test',
        'hide_solution': True,
        'hide_test': False
    }

    EXPORTS = [
        EXPORT_INITIAL,
        EXPORT_MODEL_SOLUTION,
        EXPORT_TEST
    ]

    def __init__(self, base_dir):
        # Creating directory paths...
        self.BASE_DIR = base_dir
        self.SLUG = os.path.basename(self.BASE_DIR)
        self.SRC_DIR = os.path.join(self.BASE_DIR, 'src')

        self.DIST = os.path.join(self.BASE_DIR, 'dist')
        self.SRC_DIR_2 = os.path.join(self.DIST, '_copy__src')

        self.QBUILD_DIR = os.path.join(self.BASE_DIR, '.qbuild')
        self.STATEMENT_DIR = os.path.join(self.BASE_DIR, 'statement')

        if not os.path.isdir(self.QBUILD_DIR):
            os.mkdir(self.QBUILD_DIR)

    @staticmethod
    def process_solution_comments(path, show=None):
        for item in ls_recursive(path, only_files=True):
            with open(item) as fp:
                # FIXME it reads file at once. what happens for large files?
                try:
                    lines = fp.readlines()
                except UnicodeDecodeError:
                    # file is not text
                    continue
            new_content = ''
            state = 'normal'
            comment_style = None
            for line in lines:
                if state == 'solution':
                    if any(i in line for i in Builder.SOLUTION_COMMENT_END):
                        state = 'normal'
                    elif any(i in line for i in Builder.SOLUTION_COMMENT_REPLACE):
                        state = 'replacement'
                    elif show == 'solution':
                        new_content += line
                elif state == 'replacement':
                    if any(i in line for i in Builder.SOLUTION_COMMENT_END):
                        state = 'normal'
                    elif show == 'replacement':
                        new_content += uncomment(line, comment_style)
                elif state == 'normal':
                    for scb in Builder.SOLUTION_COMMENT_BEGIN:
                        if scb in line:
                            state = 'solution'
                            comment_style = [i.strip() for i in line.split(scb) if i.strip()]
                            break
                    else:
                        new_content += line
            with open(item, 'w') as fp:
                fp.write(new_content)

    @staticmethod
    def process_initial(path, action):
        if action not in ['replace', 'delete']:
            raise Exception
        items = ls_recursive(path)
        items_to_hide = []
        for item in items:
            if item + '.initial' in items:
                items_to_hide.append(item)
        for item in items_to_hide:
            if action == 'replace':
                if os.path.isdir(item):
                    shutil.rmtree(item)
                else:
                    os.remove(item)
                os.rename(item + '.initial', item)
            elif action == 'delete':
                if os.path.isdir(item + '.initial'):
                    shutil.rmtree(item + '.initial')
                else:
                    os.remove(item + '.initial')

    @staticmethod
    def hide_ignorefile(path, ignorefile):
        if not os.path.exists(os.path.join(path, ignorefile)):
            return
        try:
            os.remove(os.path.join(path, '.gitignore'))
        except FileNotFoundError:
            pass
        os.rename(os.path.join(path, ignorefile), os.path.join(path, '.gitignore'))
        sh.git.init(_cwd=path)
        sh.git.add('.', _cwd=path)
        sh.git.clean('-xdf', _cwd=path)
        shutil.rmtree(os.path.join(path, '.git'))
        os.remove(os.path.join(path, '.gitignore'))

    def get_export_name(self, export):
        return export['export_name'].format(slug=self.SLUG)

    def get_export_path(self, export):
        return os.path.join(self.DIST, self.get_export_name(export))

    @staticmethod
    def delete_gitignore_files(path):
        for item in ls_recursive(path, only_files=True):
            if os.path.basename(item) in ['.gitignore', '.gitkeep']:
                os.remove(item)

    @staticmethod
    def process_package_json(path, export):

        def action_remove(dd, keys):
            if type(dd) is not OrderedDict:
                return
            if type(keys) is str:
                for k in list(dd.keys()):
                    if fnmatchcase(k, keys):
                        dd.pop(k)
            elif type(keys) is list:
                for i in keys:
                    action_remove(dd, i)
            elif type(keys) is OrderedDict:
                for k, v in keys.items():
                    if k in dd:
                        action_remove(dd[k], v)

        def action_add(dd, keys):
            if type(dd) is not OrderedDict:
                return
            if type(keys) is not OrderedDict:
                return
            for k, v in keys.items():
                if type(v) is not OrderedDict or k not in dd:
                    dd[k] = v
                else:
                    action_add(dd[k], v)

        for item in ls_recursive(path, only_files=True):
            if os.path.basename(item) != 'package.json':
                continue
            with open(item) as fp:
                d = json.load(fp, object_pairs_hook=OrderedDict)
            if '//' not in d:
                continue
            if export['code'] not in d['//']:
                continue
            actions = d['//'][export['code']]
            if 'remove' in actions:
                action_remove(d, actions['remove'])
            if 'add' in actions:
                action_add(d, actions['add'])
            d.pop('//')
            with open(item, 'w') as fp:
                json.dump(d, fp, indent=2)

    def is_built(self):
        for export in Builder.EXPORTS:
            if not os.path.isdir(self.get_export_path(export)):
                return False
        return True

    def render_statement(self):
        env = Environment(
            loader=load_statement_templates(self.STATEMENT_DIR),
            trim_blocks=True, lstrip_blocks=True
        )
        try:
            template = env.get_template('statement.md')
        except TemplateNotFound:
            cprint('[WARNING] "statement/statement.md" not found! Did you forget it?', color=Color.YELLOW)
            return

        outputs = [
            {
                'file_name': 'README.md',
                'extra_context': {
                    'is_readme': True
                }
            },
            {
                'file_name': 'statement.md',
                'extra_context': {
                    'is_readme': False
                }
            }
        ]
        context = {
            'has_initial': len(os.listdir(self.get_export_path(self.EXPORT_INITIAL))) > 0,
            'initial_structure': tree(self.get_export_path(self.EXPORT_INITIAL), self.SLUG),
            'solution_structure': tree(self.get_export_path(self.EXPORT_MODEL_SOLUTION), '[your-zip-file-name].zip'),
        }

        for output in outputs:
            destination_file = os.path.join(self.BASE_DIR, output['file_name'])
            destination_file_prev = os.path.join(self.QBUILD_DIR, '.{}.prev'.format(output['file_name']))
            if os.path.isfile(destination_file) and os.path.isfile(destination_file_prev) \
                    and not filecmp.cmp(destination_file, destination_file_prev):
                shutil.copyfile(destination_file, os.path.join(self.BASE_DIR, '{}.backup'.format(output['file_name'])))
                cprint(
                    '\n[WARNING] {file_name} was modified manually. '
                    'It will be auto-generated and your changes will be overwritten. '
                    'However we created a copy before overwriting: {file_name}.backup'.format(
                        file_name=output['file_name']), color=Color.YELLOW
                )

            statement = template.render(
                **context,
                **output['extra_context']
            )

            attachments_dir = os.path.join(self.STATEMENT_DIR, 'attachments')
            if os.path.isdir(attachments_dir):
                for item in os.listdir(attachments_dir):
                    path = os.path.join(attachments_dir, item)
                    if not os.path.isfile(path):
                        continue
                    statement = statement.replace(
                        os.path.join('attachments', item),
                        os.path.relpath(os.path.join(attachments_dir, item), self.BASE_DIR)
                    )
            with open(destination_file, 'w') as fp:
                fp.write(statement)
            shutil.copy2(destination_file, destination_file_prev)

    def build(self):
        # initial checks
        cprint('Performing initial checks...', color=Color.CYAN)
        if not os.path.isdir(self.SRC_DIR):
            cprint('Directory "src" not found!', color=Color.RED)
            return
        if not os.path.isfile(os.path.join(self.BASE_DIR, 'tester_config.json')):
            cprint('"tester_config.json" not found!', color=Color.RED)
            return
        if not os.path.isfile(os.path.join(self.BASE_DIR, 'valid_files')):
            cprint('"valid_files" not found!', color=Color.RED)
            return
        if not os.path.isdir(os.path.join(self.BASE_DIR, '.git')):
            cprint('This is not a git repo!', color=Color.RED)
            return
        if not os.path.isfile(os.path.join(self.SRC_DIR, '.qtest')):
            cprint('[WARNING] "src/.qtest" not found! Did you forget it?', color=Color.YELLOW)
        else:
            with open(os.path.join(self.SRC_DIR, '.qtest')) as fp:
                if not fp.read().strip():
                    cprint('[WARNING] "src/.qtest" is empty! Did you forget it?', color=Color.YELLOW)

        # copy src (except ignored files) to self.SRC_DIR_2 (dist/_copy__src)
        if os.path.exists(self.DIST):
            shutil.rmtree(self.DIST)
        os.mkdir(self.DIST)
        if os.path.exists(self.SRC_DIR_2):
            shutil.rmtree(self.SRC_DIR_2)
        os.mkdir(self.SRC_DIR_2)
        for item in ls_recursive(self.SRC_DIR, relative=True, exclude_gitignore=True, only_files=True):
            d = os.path.dirname(os.path.join(self.SRC_DIR_2, item))
            if not os.path.exists(d):
                os.makedirs(d)
            shutil.copy2(os.path.join(self.SRC_DIR, item), d)

        for export in self.EXPORTS:
            name = self.get_export_name(export)
            cprint('\nBuilding {}'.format(name), color=Color.CYAN)
            path = self.get_export_path(export)
            shutil.copytree(self.SRC_DIR_2, path)
            self.hide_ignorefile(path, '.qignore')
            if export['hide_solution']:
                self.process_initial(path, action='replace')  # must be first
                self.hide_ignorefile(path, '.qhide')
                self.hide_ignorefile(path, '.qsolution')
            else:
                self.process_initial(path, action='delete')  # must be first
            if export['hide_test']:
                self.hide_ignorefile(path, '.qtest')
            else:
                shutil.copy2(os.path.join(self.BASE_DIR, 'tester_config.json'), path)
                shutil.copy2(os.path.join(self.BASE_DIR, 'valid_files'), path)
            if export['hide_solution']:
                self.process_solution_comments(path, show='replacement')
            else:
                self.process_solution_comments(path, show='solution')
            for i in ['.qhide', '.qsolution', '.qtest', '.qignore']:
                try:
                    os.remove(os.path.join(path, i))
                except FileNotFoundError:
                    pass
            self.delete_gitignore_files(path)
            self.process_package_json(path, export)
            cprint('Creating {}.zip'.format(name), color=Color.CYAN)
            shutil.make_archive(path, 'zip', path)

        shutil.rmtree(self.SRC_DIR_2)

        self.render_statement()

        cprint('\nBuild was successful!\n', color=Color.GREEN)

    def diff(self):
        os.system('git diff --color --no-index  --src-prefix=INITIAL/ --dst-prefix=MODEL_SOLUTION/ '
                  'dist/*_initial dist/model_solution | '
                  'sed --expression="s/INITIAL\/dist\/.*_initial\///g" | '
                  'sed --expression="s/MODEL_SOLUTION\/dist\/model_solution\///g" | '
                  'qbuild_diff-so-fancy | '
                  'less --tabs=4 -RF --pattern \'^(Date|added|deleted|modified): \'')

    def main(self):
        if len(sys.argv) == 2 and sys.argv[1] == '--version':
            from qbuild import version
            print(version.__version__)
        elif len(sys.argv) == 2 and sys.argv[1] == 'diff':
            if not self.is_built():
                cprint('\nChallenge is not built. Run `qbuild` first.\n', color=Color.YELLOW)
            else:
                self.diff()
        else:
            self.build()


if __name__ == "__main__":
    Builder(os.getcwd()).main()
