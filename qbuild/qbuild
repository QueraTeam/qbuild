#!/usr/bin/env python3
import filecmp
import os
import sys
import shutil

import sh
from jinja2 import Environment, TemplateNotFound

from qbuild.color_print import Color, cprint
from qbuild.helpers import ls_recursive, load_statement_templates
from qbuild.tree import tree


class Builder:
    HIDE_BEGIN = '_q_hide_from_users_begin'
    HIDE_END = '_q_hide_from_users_end'

    EXPORTS = [
        {
            'name': '{slug}_initial',
            'hide_solution': True,
            'hide_test': True
        },
        {
            'name': 'model_solution',
            'hide_solution': False,
            'hide_test': True
        },
        {
            'name': 'test',
            'hide_solution': True,
            'hide_test': False
        }
    ]

    INITIAL_EXPORT = EXPORTS[0]

    def __init__(self, base_dir):
        # Creating directory paths...
        self.BASE_DIR = base_dir
        self.SLUG = os.path.basename(self.BASE_DIR)
        self.SRC_DIR = os.path.join(self.BASE_DIR, 'src')

        self.DIST = os.path.join(self.BASE_DIR, 'dist')
        self.SRC_DIR_2 = os.path.join(self.DIST, '_copy__src')

        self.QBUILD_DIR = os.path.join(self.BASE_DIR, '.qbuild')
        self.STATEMENT_DIR = os.path.join(self.BASE_DIR, 'statement')

        if not os.path.isdir(self.QBUILD_DIR):
            os.mkdir(self.QBUILD_DIR)

    @staticmethod
    def hide_comments(path):
        for item in ls_recursive(path, exclude_dirs=True):
            with open(item) as fp:
                # FIXME it reads file at once. what happens for large files?
                try:
                    lines = fp.readlines()
                except UnicodeDecodeError:
                    # file is not text
                    continue
            new_content = ''
            hiding = False
            for line in lines:
                if hiding:
                    if Builder.HIDE_END in line:
                        hiding = False
                else:
                    if Builder.HIDE_BEGIN in line:
                        hiding = True
                    else:
                        new_content += line
            with open(item, 'w') as fp:
                fp.write(new_content)

    @staticmethod
    def process_initial(path, action):
        if action not in ['replace', 'delete']:
            raise Exception
        items = ls_recursive(path)
        items_to_hide = []
        for item in items:
            if item + '.initial' in items:
                items_to_hide.append(item)
        for item in items_to_hide:
            if action == 'replace':
                if os.path.isdir(item):
                    shutil.rmtree(item)
                else:
                    os.remove(item)
                os.rename(item + '.initial', item)
            elif action == 'delete':
                if os.path.isdir(item + '.initial'):
                    shutil.rmtree(item + '.initial')
                else:
                    os.remove(item + '.initial')

    @staticmethod
    def hide_ignorefile(path, ignorefile):
        if not os.path.exists(os.path.join(path, ignorefile)):
            return
        try:
            os.remove(os.path.join(path, '.gitignore'))
        except FileNotFoundError:
            pass
        os.rename(os.path.join(path, ignorefile), os.path.join(path, '.gitignore'))
        sh.git.init(_cwd=path)
        sh.git.add('.', _cwd=path)
        sh.git.clean('-xdf', _cwd=path)
        shutil.rmtree(os.path.join(path, '.git'))
        os.remove(os.path.join(path, '.gitignore'))

    def get_export_name(self, export):
        return export['name'].format(slug=self.SLUG)

    def get_export_path(self, export):
        return os.path.join(self.DIST, self.get_export_name(export))

    @staticmethod
    def delete_gitignore_files(path):
        for item in ls_recursive(path, exclude_dirs=True):
            if os.path.basename(item) in ['.gitignore', '.gitkeep']:
                os.remove(item)

    def is_built(self):
        for export in Builder.EXPORTS:
            if not os.path.isdir(self.get_export_path(export)):
                return False
        return True

    def render_statement(self):
        env = Environment(loader=load_statement_templates(self.STATEMENT_DIR))
        try:
            template = env.get_template('statement.md')
        except TemplateNotFound:
            cprint('[WARNING] "statement/statement.md" not found! Did you forget it?', color=Color.YELLOW)
            return

        destination_file = os.path.join(self.BASE_DIR, 'README.md')
        destination_file_copy = os.path.join(self.QBUILD_DIR, '.README.md.prev')
        if os.path.isfile(destination_file) and os.path.isfile(destination_file_copy) and not filecmp.cmp(destination_file, destination_file_copy):
            shutil.copyfile(destination_file, os.path.join(self.BASE_DIR, 'README.md.backup'))
            cprint('[WARNING] README.md was modified manually. README.md will be auto-generated and your changes will be overwritten. However we created a copy before overwriting: README.md.backup', color=Color.YELLOW)

        has_initial = len(os.listdir(self.get_export_path(self.INITIAL_EXPORT))) > 0

        statement = template.render(has_initial=has_initial,
                                    initial_structure=tree(self.get_export_path(self.INITIAL_EXPORT)))

        attachments_dir = os.path.join(self.STATEMENT_DIR, 'attachments')
        if os.path.isdir(attachments_dir):
            for item in os.listdir(attachments_dir):
                path = os.path.join(attachments_dir, item)
                if not os.path.isfile(path):
                    continue
                statement = statement.replace(
                    os.path.join('attachments', item),
                    os.path.relpath(os.path.join(attachments_dir, item), self.BASE_DIR)
                )
        with open(destination_file, 'w') as fp:
            fp.write(statement)
        shutil.copy2(destination_file, destination_file_copy)

    def build(self):
        # initial checks
        cprint('Performing initial checks...', color=Color.CYAN)
        if not os.path.isdir(self.SRC_DIR):
            cprint('Directory "src" not found!', color=Color.RED)
            return
        if not os.path.isfile(os.path.join(self.BASE_DIR, 'tester_config.json')):
            cprint('"tester_config.json" not found!', color=Color.RED)
            return
        if not os.path.isfile(os.path.join(self.BASE_DIR, 'valid_files')):
            cprint('"valid_files" not found!', color=Color.RED)
            return
        if not os.path.isdir(os.path.join(self.BASE_DIR, '.git')):
            cprint('This is not a git repo!', color=Color.RED)
            return
        if not os.path.isfile(os.path.join(self.SRC_DIR, '.qtest')):
            cprint('[WARNING] "src/.qtest" not found! Did you forget it?', color=Color.YELLOW)
        else:
            with open(os.path.join(self.SRC_DIR, '.qtest')) as fp:
                if not fp.read().strip():
                    cprint('[WARNING] "src/.qtest" is empty! Did you forget it?', color=Color.YELLOW)

        # copy src (except ignored files) to self.SRC_DIR_2 (dist/_copy__src)
        if os.path.exists(self.DIST):
            shutil.rmtree(self.DIST)
        os.mkdir(self.DIST)
        if os.path.exists(self.SRC_DIR_2):
            shutil.rmtree(self.SRC_DIR_2)
        os.mkdir(self.SRC_DIR_2)
        for item in ls_recursive(self.SRC_DIR, relative=True, exclude_gitignore=True, exclude_dirs=True):
            d = os.path.dirname(os.path.join(self.SRC_DIR_2, item))
            if not os.path.exists(d):
                os.makedirs(d)
            shutil.copy2(os.path.join(self.SRC_DIR, item), d)

        for export in self.EXPORTS:
            name = self.get_export_name(export)
            cprint('\nBuilding {}'.format(name), color=Color.CYAN)
            path = self.get_export_path(export)
            shutil.copytree(self.SRC_DIR_2, path)
            if export['hide_solution']:
                self.process_initial(path, action='replace')  # must be first
                self.hide_ignorefile(path, '.qhide')
                self.hide_comments(path)
            else:
                self.process_initial(path, action='delete')  # must be first
            if export['hide_test']:
                self.hide_ignorefile(path, '.qtest')
            else:
                shutil.copy2(os.path.join(self.BASE_DIR, 'tester_config.json'), path)
                shutil.copy2(os.path.join(self.BASE_DIR, 'valid_files'), path)
            for i in ['.qhide', '.qtest']:
                try:
                    os.remove(os.path.join(path, i))
                except FileNotFoundError:
                    pass
            self.delete_gitignore_files(path)
            cprint('Creating {}.zip'.format(name), color=Color.CYAN)
            shutil.make_archive(path, 'zip', path)
        print()

        shutil.rmtree(self.SRC_DIR_2)

        self.render_statement()

        cprint('\nBuild was successful!\n', color=Color.GREEN)

    def diff(self):
        os.system('git diff --color --no-index  --src-prefix=INITIAL/ --dst-prefix=MODEL_SOLUTION/ '
                  'dist/*_initial dist/model_solution | '
                  'sed --expression="s/INITIAL\/dist\/.*_initial\///g" | '
                  'sed --expression="s/MODEL_SOLUTION\/dist\/model_solution\///g" | '
                  'qbuild_diff-so-fancy | '
                  'less --tabs=4 -RF --pattern \'^(Date|added|deleted|modified): \'')

    def main(self):
        if len(sys.argv) == 2 and sys.argv[1] == '--version':
            from qbuild import version
            print(version.__version__)
        elif len(sys.argv) == 2 and sys.argv[1] == 'diff':
            if not self.is_built():
                cprint('\nChallenge is not built. Run `qbuild` first.\n', color=Color.YELLOW)
            else:
                self.diff()
        else:
            self.build()


if __name__ == "__main__":
    Builder(os.getcwd()).main()
