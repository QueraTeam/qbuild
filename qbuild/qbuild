#!/usr/bin/env python3
import os
import sys
import shutil

import sh

from qbuild.color_print import Color, cprint
from qbuild.helpers import ls_recursive


class Builder:
    HIDE_BEGIN = '_q_hide_from_users_begin'
    HIDE_END = '_q_hide_from_users_end'

    EXPORTS = [
        {
            'name': '{slug}_initial',
            'hide_solution': True,
            'hide_test': True
        },
        {
            'name': 'model_solution',
            'hide_solution': False,
            'hide_test': True
        },
        {
            'name': 'test',
            'hide_solution': True,
            'hide_test': False
        }
    ]

    def __init__(self, base_dir):
        # Creating directory paths...
        self.BASE_DIR = base_dir
        self.SLUG = os.path.basename(self.BASE_DIR)
        self.SRC_DIR = os.path.join(self.BASE_DIR, 'src')

        self.DIST = os.path.join(self.BASE_DIR, 'dist')
        self.SRC_DIR_2 = os.path.join(self.DIST, '_copy__src')

    @staticmethod
    def hide_comments(path):
        for item in ls_recursive(path, exclude_dirs=True):
            with open(item) as fp:
                # FIXME it reads file at once. what happens for large files?
                try:
                    lines = fp.readlines()
                except UnicodeDecodeError:
                    # file is not text
                    continue
            new_content = ''
            hiding = False
            for line in lines:
                if hiding:
                    if Builder.HIDE_END in line:
                        hiding = False
                else:
                    if Builder.HIDE_BEGIN in line:
                        hiding = True
                    else:
                        new_content += line
            with open(item, 'w') as fp:
                fp.write(new_content)

    @staticmethod
    def process_initial(path, action):
        if action not in ['replace', 'delete']:
            raise Exception
        items = ls_recursive(path)
        items_to_hide = []
        for item in items:
            if item + '.initial' in items:
                items_to_hide.append(item)
        for item in items_to_hide:
            if action == 'replace':
                if os.path.isdir(item):
                    shutil.rmtree(item)
                else:
                    os.remove(item)
                os.rename(item + '.initial', item)
            elif action == 'delete':
                if os.path.isdir(item + '.initial'):
                    shutil.rmtree(item + '.initial')
                else:
                    os.remove(item + '.initial')

    @staticmethod
    def hide_ignorefile(path, ignorefile):
        if not os.path.exists(os.path.join(path, ignorefile)):
            return
        try:
            os.remove(os.path.join(path, '.gitignore'))
        except FileNotFoundError:
            pass
        os.rename(os.path.join(path, ignorefile), os.path.join(path, '.gitignore'))
        sh.git.init(_cwd=path)
        sh.git.add('.', _cwd=path)
        sh.git.clean('-xdf', _cwd=path)
        shutil.rmtree(os.path.join(path, '.git'))
        os.remove(os.path.join(path, '.gitignore'))

    @staticmethod
    def delete_gitignore_files(path):
        for item in ls_recursive(path, exclude_dirs=True):
            if os.path.basename(item) in ['.gitignore', '.gitkeep']:
                os.remove(item)

    def main(self):
        if sys.argv[1] == '--version':
            import version
            print(version.__version__)
            return
        # initial checks
        if not os.path.isdir(self.SRC_DIR):
            cprint('Directory "src" not found!', color=Color.RED)
            return
        if not os.path.isfile(os.path.join(self.BASE_DIR, 'tester_config.json')):
            cprint('"tester_config.json" not found!', color=Color.RED)
            return
        if not os.path.isfile(os.path.join(self.BASE_DIR, 'valid_files')):
            cprint('"valid_files" not found!', color=Color.RED)
            return
        if not os.path.isdir(os.path.join(self.BASE_DIR, '.git')):
            cprint('This is not a git repo!', color=Color.RED)
            return

        # copy src (except ignored files) to self.SRC_DIR_2 (dist/_copy__src)
        if os.path.exists(self.DIST):
            shutil.rmtree(self.DIST)
        os.mkdir(self.DIST)
        if os.path.exists(self.SRC_DIR_2):
            shutil.rmtree(self.SRC_DIR_2)
        os.mkdir(self.SRC_DIR_2)
        for item in ls_recursive(self.SRC_DIR, relative=True, exclude_gitignore=True, exclude_dirs=True):
            d = os.path.dirname(os.path.join(self.SRC_DIR_2, item))
            if not os.path.exists(d):
                os.makedirs(d)
            shutil.copy2(os.path.join(self.SRC_DIR, item), d)

        for export in self.EXPORTS:
            name = export['name'].format(slug=self.SLUG)
            path = os.path.join(self.DIST, name)
            shutil.copytree(self.SRC_DIR_2, path)
            if export['hide_solution']:
                self.process_initial(path, action='replace')  # must be first
                self.hide_ignorefile(path, '.qhide')
                self.hide_comments(path)
            else:
                self.process_initial(path, action='delete')  # must be first
            if export['hide_test']:
                self.hide_ignorefile(path, '.qtest')
            else:
                shutil.copy2(os.path.join(self.BASE_DIR, 'tester_config.json'), path)
                shutil.copy2(os.path.join(self.BASE_DIR, 'valid_files'), path)
            for i in ['.qhide', '.qtest']:
                try:
                    os.remove(os.path.join(path, i))
                except FileNotFoundError:
                    pass
            self.delete_gitignore_files(path)
            shutil.make_archive(path, 'zip', path)

        shutil.rmtree(self.SRC_DIR_2)

        cprint('Build was successful!', color=Color.GREEN)


if __name__ == "__main__":
    Builder(os.getcwd()).main()
